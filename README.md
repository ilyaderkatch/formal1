Условие:
Дано регулярное выражение R в обратной польской записи, задающее язык L, натуральные числа l и k. Требуется определить, содержит ли язык L слова, чья длина равна l по модулю k.

Алгоритм:

Алгоритм совершает обработку выражения, записанного в польской записи с помощью стека. В каждой ячейке стека вместо подстроки в виде регулярного выражения записан сет возможных остатков длины данного подвыражения. Каждый новый считанный символ задает изменение в стеке:
1. Буквенный символ(a, b, c) - в стек записывается сет из одного элемента - остатка один
2. Пустой элемент(1) - в стек записывается сет из одного элемента - остатка ноль
3. Конкатенация строк(.) - из стека достаются последние два сета, из них строится новый путем попарного сложения всех возможных элементов по модулю
4. Сложение строк(+) - из стека достаются последние два сета, из них строится новый путем объединения старых
5. Операция Клини(*) - из стека достается последний сет, и рассматриваются все возможные остатки, порожденные сложением одного какгого-либо элемента сета
Ошибка распознования возникает тогда и только тогда, когда в конце остается более одного сета в стеке, или при операциях 3-5 не хватает элементов в стеке, или незнакомый символ.

Пояснение к функциям:

data_input() - ввод даты, разрезает вводные даты на три строки: будущая строка и два числа

conc(set1, set2, k) - конкатенация двух сетов по модулю k

gcd(m, n) - НОД двух чисел

degree(set_of_remains, k) - операция клини по модулю k для сета

update_words_len(str, k) - функция-ответ - возвращает тьюпл вида (bool, set) - где первое значение true <=> произошла ошибка распознования текста, а второе значение - множество всех возможных остатков слов, задаваемых регуляркой

find_answer(input_tuple) - выводит ответ в человеческой форме
